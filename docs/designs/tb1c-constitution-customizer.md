# TB1c: LLM-Assisted Constitution Customization

**Status:** Proposed
**Date:** 2026-02-19
**Updated:** 2026-02-21
**Author:** IronCurtain Engineering
**Depends on:** TB1b (Fetch Server & User Credentials)

## 1. Executive Summary

TB1c adds an LLM-assisted conversational CLI for users to customize their constitution in natural language. This builds on the user constitution file introduced in TB1a (`multi-server-onboarding.md`) and the credential/config infrastructure from TB1b (`tb1b-fetch-credentials-customizer.md`).

## 2. Overview

Users customize their constitution through a multi-turn conversation with an LLM. The LLM translates user intent into policy statements and validates them through the compile-policy pipeline. A base user constitution ships with IronCurtain to provide sensible defaults; the customizer helps users refine it.

### Prerequisites

- Tool annotations must already exist (`tool-annotations.json`). These ship with IronCurtain and are generated by `ironcurtain annotate-tools`.
- No running MCP servers are required — the customizer reads annotations from disk.

## 3. CLI Command

```bash
ironcurtain customize-policy
```

This is a subcommand of the `ironcurtain` CLI, following the same pattern as `compile-policy`, `refresh-lists`, etc. Registered in `src/cli.ts` via dynamic import.

## 4. Base User Constitution

IronCurtain ships a base user constitution at `src/config/constitution-user-base.md`. This provides sensible default user-level guidance (e.g., common safety rules for web browsing, file access patterns). On first run of `customize-policy`, if no user constitution exists at `~/.ironcurtain/constitution-user.md`, the base is copied there as a starting point.

The base user constitution is also prepended (as read-only context) to the LLM prompt so the model understands the defaults the user is building on. The user constitution file at `~/.ironcurtain/constitution-user.md` is the only file the customizer writes to.

## 5. Interaction Flow

```
1.  User runs `ironcurtain customize-policy`
2.  System loads tool annotations from disk
3.  System loads base constitution + current user constitution
4.  System displays current user constitution (or "no customizations yet")
5.  Conversational loop begins:
    a. User types a request in natural language
       e.g., "I want git push to always require approval,
              and allow fetching from any .gov domain without approval"
    b. LLM generates proposed user constitution (complete replacement)
    c. System shows inline diff (old → new)
    d. User chooses: accept / reject / refine
       - accept: proceed to compilation
       - reject: discard changes, prompt for new request
       - refine: user provides follow-up, loop back to (b)
    e. On accept: continue the conversation or type "done" to finish
6.  System writes ~/.ironcurtain/constitution-user.md
    (backs up previous version to constitution-user.md.bak)
7.  System runs compile-policy to regenerate artifacts
8.  System shows compilation result (pass/fail)
9.  On failure: show errors, offer to revert from .bak file
10. On success: display summary of active policy rules
```

### Diff Display

Diffs are shown inline in the terminal using a unified diff format, colorized with chalk:

```
  User Constitution Changes:
  ─────────────────────────────────────────
    The agent may read documents in ~/Documents.
  - The agent may fetch web content from popular news sites.
  + The agent may fetch web content from popular news sites and *.gov domains without approval.
  + The agent must receive human approval before any git push operation.
  ─────────────────────────────────────────
  [a]ccept  [r]eject  [e]dit  →
```

Lines prefixed with `-` (red) are removed, `+` (green) are added, and unprefixed lines are unchanged context. This uses a simple line-level diff (e.g., `diff` library from npm or a minimal implementation).

## 6. LLM Prompt

The customizer uses `policyModelId` from user config (same model as compile-policy, defaults to Sonnet).

### System Prompt

```typescript
// src/pipeline/constitution-customizer.ts

function buildSystemPrompt(
  baseConstitution: string,
  toolAnnotations: ToolAnnotation[],
): string {
  return `You are helping a user customize their IronCurtain security policy.

## Base Constitution (read-only, cannot be modified)
${baseConstitution}

## Available Tools
${formatAnnotationsForPrompt(toolAnnotations)}

## Instructions
You will help the user iteratively refine their personal policy customizations.
When asked to make changes, generate the COMPLETE updated user constitution section.

Rules:
1. Only generate the user customization section, never modify the base constitution.
2. Each line should be a clear, specific policy statement.
3. Use concrete terms the policy compiler can translate to rules:
   - "allow" / "deny" / "require approval" (maps to escalate)
   - Reference specific tools (git push, git commit) or categories (git operations)
   - Reference domains when relevant (github.com, *.gov)
   - Reference paths when relevant (~/Documents, ~/Downloads)
4. Avoid vague statements. "Be careful with git" is not enforceable.
5. Always return the complete user constitution section (not just the diff).
6. If the user's request conflicts with the base constitution, explain the conflict
   and suggest an alternative that works within the base constraints.
7. If the user's request is ambiguous, ask a clarifying question before generating.
`;
}
```

### Per-Turn User Message

Each turn sends the current user constitution state plus the user's message:

```typescript
function buildUserMessage(
  currentUserConstitution: string | undefined,
  userRequest: string,
): string {
  const current = currentUserConstitution
    ? `## Current User Customizations\n${currentUserConstitution}`
    : '## No existing user customizations.';
  return `${current}\n\n## User Request\n"${userRequest}"`;
}
```

The conversation history is maintained across turns so the LLM has context from earlier refinements.

## 7. Implementation Notes

- Subcommand of `ironcurtain` CLI, registered in `src/cli.ts` alongside existing commands.
- Uses `createPipelineLlm()` from `pipeline-shared.ts` for model setup and logging.
- Tool annotations loaded from disk via `loadExistingArtifact()` — no MCP server connections needed.
- User constitution lives at `~/.ironcurtain/constitution-user.md` (via `getUserConstitutionPath()`).
- Before writing, the existing user constitution is backed up to `constitution-user.md.bak`.
- Compilation is invoked programmatically (importing `compile.ts`'s `main()`), not via subprocess.
- Constitution versioning: user constitution only adds guidance, never modifies base principles. If a base update conflicts, compile-policy fails, alerting the user.
- LLM interactions logged to `llm-interactions.jsonl` in the generated directory (via pipeline logging middleware).
- Terminal input uses Node.js `readline` for the conversational loop.

## 8. Implementation Phase

Phase numbering continues from TB1b (phases 4-5).

### Phase 6: Constitution Customizer CLI

**New files:**
- `src/config/constitution-user-base.md` -- base user constitution shipped with IronCurtain
- `src/pipeline/constitution-customizer.ts` -- LLM-assisted conversational customization logic

**Files changed:**
- `src/cli.ts` -- register `customize-policy` subcommand
- `src/config/paths.ts` -- add `getBaseUserConstitutionPath()` helper

## 9. Test Strategy

### Unit Tests (`test/constitution-customizer.test.ts`)

**Prompt construction:**
- `buildSystemPrompt()` includes base constitution and tool annotations
- `buildUserMessage()` includes current user constitution when present
- `buildUserMessage()` handles missing user constitution gracefully

**Diff generation:**
- Correctly identifies added, removed, and unchanged lines
- Handles empty old constitution (all additions)
- Handles empty new constitution (all removals)
- Handles identical constitutions (no changes)

**Backup and revert:**
- Writing constitution creates `.bak` of previous version
- Revert restores from `.bak` file
- Revert when no `.bak` exists produces clear error
- First-time write (no existing file) skips backup

**Base constitution seeding:**
- First run copies base to user path when no user constitution exists
- Does not overwrite existing user constitution

### Integration Tests (`test/constitution-customizer-integration.test.ts`)

**End-to-end flow (with mocked LLM):**
- Mock LLM returns valid constitution text → written to disk → compile-policy succeeds
- Mock LLM returns constitution that causes compile failure → revert offered → `.bak` restored
- Multi-turn refinement: first response rejected, second accepted
- User constitution is correctly merged with base for compilation

**Compilation integration:**
- Generated user constitution compiles without errors via real compile-policy pipeline (may require LLM, so guarded behind `INTEGRATION_TEST` flag)
- Combined hash changes when user constitution changes
- Compilation cache invalidated after customizer writes new constitution
