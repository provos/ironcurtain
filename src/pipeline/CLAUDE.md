# Policy Compilation Pipeline (`src/pipeline/`)

Two-command offline pipeline that produces generated artifacts in `src/config/generated/`:

1. **`npm run annotate-tools`** (`annotate.ts`) - Developer task. Connects to MCP servers, classifies tool arguments via LLM, writes **tool-annotations.json**. Only needs re-running when servers, tools, or the argument role registry change. Roles are filtered per-server via `serverNames` on `RoleDefinition`. Servers that fail to connect (e.g., Docker unavailable for the GitHub server) are skipped with a warning; previously-cached annotations for skipped servers are preserved.
2. **`npm run compile-policy`** (`compile.ts`) - User task. Loads annotations from disk, compiles the constitution into **compiled-policy.json**, generates **test-scenarios.json**, and verifies via LLM judge. Requires `tool-annotations.json` to exist.

**Dynamic Lists** - When the constitution references categories ("major news sites", "my contacts"), the compiler emits `@list-name` symbolic references in rules and `listDefinitions` in `compiled-policy.json`. A resolution sub-step (between compilation and scenario generation) resolves each list via LLM (knowledge-based) or LLM+MCP tool-use (data-backed, e.g. contacts). Resolved values are written to **dynamic-lists.json** (`src/pipeline/list-resolver.ts`). At load time, `PolicyEngine` expands `@list-name` â†’ concrete values, keeping the evaluation hot path unchanged. Three list types: `domains` (wildcard matching via `domainMatchesAllowlist`), `emails` (case-insensitive), `identifiers` (exact match), defined in `dynamic-list-types.ts`. Users can inspect/edit resolved lists via `manualAdditions`/`manualRemovals`. `ironcurtain refresh-lists` re-resolves without full recompilation. Domain-typed lists go in `DomainCondition.allowed`; non-domain types use `ListCondition` (new field on `CompiledRuleCondition`).

All artifacts use content-hash caching (`inputHash`) to skip unnecessary LLM calls. The LLM prompt text is included in the hash so template changes invalidate the cache. Artifacts are written to disk immediately after each step (not gated on verification). When verification fails, a compile-verify-repair loop feeds failures back to the compiler for targeted repair (up to 2 attempts). LLM interactions logged to `llm-interactions.jsonl`.
